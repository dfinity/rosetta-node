// DFN-467: clippy complains about the code generated by derive(Arbitrary)
#![cfg_attr(test, allow(clippy::unit_arg))]
//! This module defines the various http requests that the internet computer is
//! prepared to handle.

use super::{
    validate_ingress_expiry, validate_ingress_expiry_range, Blob, HttpHandlerError, MessageId,
};
use crate::{
    crypto::SignedBytesWithoutDomainSeparator, messages::message_id::hash_of_map, CanisterId,
    CountBytes, PrincipalId, Time, UserId,
};
use ic_crypto_tree_hash::{MixedHashTree, Path};
use ic_protobuf::types::v1 as pb;
use maplit::btreemap;
#[cfg(test)]
use proptest_derive::Arbitrary;
use serde::{Deserialize, Serialize};
use std::{
    collections::{BTreeMap, BTreeSet},
    convert::TryFrom,
};

/// Describes the fields of a canister update call as defined in
/// https://docs.dfinity.systems/public#api-update.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct HttpCanisterUpdate {
    pub canister_id: Blob,
    pub method_name: String,
    pub arg: Blob,
    pub sender: Blob,
    /// Indicates when the message should expire.  Represented as nanoseconds
    /// since UNIX epoch.
    pub ingress_expiry: u64,
    // Do not include omitted fields in MessageId calculation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<Blob>,
}

impl CountBytes for HttpCanisterUpdate {
    fn count_bytes(&self) -> usize {
        let mut count = std::mem::size_of::<Self>()
            + self.canister_id.0.len()
            + self.method_name.len()
            + self.arg.0.len()
            + self.sender.0.len();
        if let Some(nonce) = &self.nonce {
            count += nonce.0.len();
        }
        count
    }
}

/// Describes the contents of a /api/v1/submit request.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
#[cfg_attr(test, derive(Arbitrary))]
#[serde(rename_all = "snake_case")]
#[serde(tag = "request_type")]
pub enum HttpSubmitContent {
    Call {
        #[serde(flatten)]
        update: HttpCanisterUpdate,
    },
}

/// Describes the fields of a canister query call (a query from a user to a
/// canister) as defined in https://docs.dfinity.systems/public#api-query
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HttpUserQuery {
    pub canister_id: Blob,
    pub method_name: String,
    pub arg: Blob,
    pub sender: Blob,
    /// Indicates when the message should expire.  Represented as nanoseconds
    /// since UNIX epoch.
    pub ingress_expiry: u64,
    // Do not include omitted fields in MessageId calculation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<Blob>,
}

/// Describes the fields of a request status as defined in
/// https://docs.dfinity.systems/public#api-request-status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HttpRequestStatus {
    pub request_id: Blob,
    /// Indicates when the message should expire.  Represented as nanoseconds
    /// since UNIX epoch.
    pub ingress_expiry: u64,
    // Do not include omitted fields in MessageId calculation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<Blob>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HttpReadState {
    pub sender: Blob,
    // A list of paths, where a path is itself a sequence of labels.
    pub paths: Vec<Path>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<Blob>,
    pub ingress_expiry: u64,
}

/// Describes the contents of a /api/v1/read request.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
#[serde(tag = "request_type")]
pub enum HttpReadContent {
    Query {
        #[serde(flatten)]
        query: HttpUserQuery,
    },
    RequestStatus {
        #[serde(flatten)]
        request_status: HttpRequestStatus,
    },
    ReadState {
        #[serde(flatten)]
        read_state: HttpReadState,
    },
}

/// Describes the request envelope as defined in
/// https://docs.dfinity.systems/public#authentication.  The content should
/// either be `HttpSubmitContent` or `HttpReadContent`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct HttpRequestEnvelope<C> {
    pub content: C,
    pub sender_pubkey: Option<Blob>,
    pub sender_sig: Option<Blob>,
    pub sender_delegation: Option<Vec<SignedDelegation>>,
}

/// Describes a delegation map as defined in
/// https://docs.dfinity.systems/public#delegation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct Delegation {
    pubkey: Blob,
    expiration: Time,
    targets: Option<Vec<Blob>>,
}

impl Delegation {
    pub fn new(pubkey: Vec<u8>, expiration: Time) -> Self {
        Self {
            pubkey: Blob(pubkey),
            expiration,
            targets: None,
        }
    }

    pub fn new_with_targets(pubkey: Vec<u8>, expiration: Time, targets: Vec<CanisterId>) -> Self {
        Self {
            pubkey: Blob(pubkey),
            expiration,
            targets: Some(targets.iter().map(|c| Blob(c.get().to_vec())).collect()),
        }
    }

    pub fn pubkey(&self) -> &Vec<u8> {
        &self.pubkey.0
    }

    pub fn expiration(&self) -> Time {
        self.expiration
    }

    pub fn targets(&self) -> Result<Option<BTreeSet<CanisterId>>, String> {
        match &self.targets {
            None => Ok(None),
            Some(targets) => {
                let mut target_canister_ids = BTreeSet::new();
                for target in targets {
                    target_canister_ids.insert(
                        CanisterId::new(
                            PrincipalId::try_from(target.0.as_slice())
                                .map_err(|e| format!("Error parsing canister ID: {}", e))?,
                        )
                        .map_err(|e| format!("Error parsing canister ID: {}", e))?,
                    );
                }
                Ok(Some(target_canister_ids))
            }
        }
    }
}

impl SignedBytesWithoutDomainSeparator for Delegation {
    fn as_signed_bytes_without_domain_separator(&self) -> Vec<u8> {
        use RawHttpRequestVal::*;

        let mut map = btreemap! {
            "pubkey" => Bytes(self.pubkey.0.clone()),
            "expiration" => U64(self.expiration.as_nanos_since_unix_epoch()),
        };
        if let Some(targets) = &self.targets {
            map.insert(
                "targets",
                Array(targets.iter().map(|t| Bytes(t.0.clone())).collect()),
            );
        }

        hash_of_map(&map).to_vec()
    }
}

/// Describes a delegation as defined in
/// https://docs.dfinity.systems/public#delegation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct SignedDelegation {
    delegation: Delegation,
    signature: Blob,
}

impl SignedDelegation {
    pub fn new(delegation: Delegation, signature: Vec<u8>) -> Self {
        Self {
            delegation,
            signature: Blob(signature),
        }
    }

    pub fn delegation(&self) -> &Delegation {
        &self.delegation
    }

    pub fn take_delegation(self) -> Delegation {
        self.delegation
    }

    pub fn signature(&self) -> &Blob {
        &self.signature
    }
}

/// The different types of values supported in `RawHttpRequest`.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum RawHttpRequestVal {
    Bytes(#[serde(with = "serde_bytes")] Vec<u8>),
    String(String),
    U64(u64),
    Array(Vec<RawHttpRequestVal>),
}

impl CountBytes for RawHttpRequestVal {
    fn count_bytes(&self) -> usize {
        match self {
            Self::Bytes(bytes) => bytes.len(),
            Self::String(string) => string.len(),
            Self::U64(_) => 8,
            Self::Array(elements) => elements.iter().map(|e| e.count_bytes()).sum(),
        }
    }
}

impl From<&RawHttpRequestVal> for pb::HttpRequestVal {
    fn from(val: &RawHttpRequestVal) -> Self {
        Self {
            val: Some(match val {
                RawHttpRequestVal::Bytes(bytes) => {
                    pb::http_request_val::Val::RawBytes(bytes.to_vec())
                }
                RawHttpRequestVal::String(string) => {
                    pb::http_request_val::Val::Str(string.to_string())
                }
                RawHttpRequestVal::U64(v) => pb::http_request_val::Val::U64(*v),
                RawHttpRequestVal::Array(arr) => {
                    pb::http_request_val::Val::Array(pb::HttpRequestArr {
                        values: arr.iter().map(Self::from).collect(),
                    })
                }
            }),
        }
    }
}

/// A map of all the relevant information needed to compute a `MessageId`.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct RawHttpRequest(pub BTreeMap<String, RawHttpRequestVal>);

impl RawHttpRequest {
    pub(crate) fn take_bytes(&mut self, key: &str) -> Vec<u8> {
        match self.0.remove(key).unwrap() {
            RawHttpRequestVal::Bytes(raw) => raw,
            val => unreachable!("Expected `{}` to be a blob, got {:?}", key, val),
        }
    }

    pub(crate) fn take_string(&mut self, key: &str) -> String {
        match self.0.remove(key).unwrap() {
            RawHttpRequestVal::String(raw) => raw,
            val => unreachable!("Expected `{}` to be a String, got {:?}", key, val),
        }
    }

    pub(crate) fn take_u64(&mut self, key: &str) -> u64 {
        match self.0.remove(key).unwrap() {
            RawHttpRequestVal::U64(raw) => raw,
            val => unreachable!("Expected `{}` to be an int, got {:?}", key, val),
        }
    }

    pub(crate) fn take_sender(&mut self) -> UserId {
        let sender_field = "sender".to_string();
        UserId::from(match self.0.remove(&sender_field).unwrap() {
            RawHttpRequestVal::Bytes(raw) => {
                PrincipalId::try_from(&raw[..]).expect("Failed to parse source")
            }
            val => unreachable!("Expected `{}` to be a blob, got {:?}", sender_field, val),
        })
    }
}

impl CountBytes for RawHttpRequest {
    fn count_bytes(&self) -> usize {
        self.0
            .iter()
            .map(|(key, val)| key.len() + val.count_bytes())
            .sum()
    }
}

// TODO(akhi): Perhaps introduce a method to check if valid PrincipalId without
// building one.
fn validate_principal_id(field: &str, bytes: &[u8]) -> Result<(), HttpHandlerError> {
    match PrincipalId::try_from(bytes) {
        Ok(_) => Ok(()),
        Err(err) => Err(HttpHandlerError::InvalidPrincipalId(format!(
            "Converting {} to PrincipalId failed with {}",
            field, err,
        ))),
    }
}

// This is the first time this http request is parsed.  Perform all the validity
// checks here so that any further conversions do not need to do error checking.
impl TryFrom<(HttpCanisterUpdate, Time)> for RawHttpRequest {
    type Error = HttpHandlerError;

    fn try_from(input: (HttpCanisterUpdate, Time)) -> Result<Self, Self::Error> {
        use RawHttpRequestVal::*;
        let (update, current_time) = input;
        let canister_id_field = "canister_id".to_string();
        validate_principal_id(&canister_id_field, &update.canister_id.0)?;
        validate_ingress_expiry_range(update.ingress_expiry, current_time)?;

        let mut map = btreemap! {
            "request_type".to_string() => String("call".to_string()),
            canister_id_field => Bytes(update.canister_id.0),
            "method_name".to_string() => String(update.method_name),
            "arg".to_string() => Bytes(update.arg.0),
            "ingress_expiry".to_string() => U64(update.ingress_expiry),
            "sender".to_string() => Bytes(update.sender.0),
        };
        if let Some(nonce) = update.nonce {
            map.insert("nonce".to_string(), Bytes(nonce.0));
        }
        Ok(Self(map))
    }
}

// This is the first time this http request is parsed.  Perform all the validity
// checks here so that any further conversions do not need to do error checking.
impl TryFrom<(HttpUserQuery, Time)> for RawHttpRequest {
    type Error = HttpHandlerError;

    fn try_from(input: (HttpUserQuery, Time)) -> Result<Self, Self::Error> {
        use RawHttpRequestVal::*;
        let (query, current_time) = input;
        let canister_id_field = "canister_id".to_string();
        validate_principal_id(&canister_id_field, &query.canister_id.0)?;
        validate_ingress_expiry(query.ingress_expiry, current_time)?;

        let mut map = btreemap! {
            "request_type".to_string() => String("query".to_string()),
            "canister_id".to_string() => Bytes(query.canister_id.0),
            "method_name".to_string() => String(query.method_name),
            "arg".to_string() => Bytes(query.arg.0),
            "ingress_expiry".to_string() => U64(query.ingress_expiry),
            "sender".to_string() => Bytes(query.sender.0),
        };
        if let Some(nonce) = query.nonce {
            map.insert("nonce".to_string(), Bytes(nonce.0));
        }
        Ok(Self(map))
    }
}

// This is the first time this http request is parsed.  Perform all the validity
// checks here so that any further conversions do not need to do error checking.
impl TryFrom<(HttpRequestStatus, Time)> for RawHttpRequest {
    type Error = HttpHandlerError;

    fn try_from(input: (HttpRequestStatus, Time)) -> Result<Self, Self::Error> {
        use RawHttpRequestVal::*;
        let (request_status, current_time) = input;
        MessageId::try_from(request_status.request_id.0.as_slice()).map_err(|err| {
            HttpHandlerError::InvalidMessageId(format!(
                "Converting {:?} to MessageId failed with {}",
                request_status.request_id, err
            ))
        })?;
        validate_ingress_expiry(request_status.ingress_expiry, current_time)?;

        let mut map = btreemap! {
            "request_type".to_string() => String("request_status".to_string()),
            "request_id".to_string() => Bytes(request_status.request_id.0),
            "ingress_expiry".to_string() => U64(request_status.ingress_expiry),
        };
        if let Some(nonce) = request_status.nonce {
            map.insert("nonce".to_string(), Bytes(nonce.0));
        }
        Ok(Self(map))
    }
}

// This is the first time this http request is parsed.  Perform all the validity
// checks (but not expiry check) here so that any further conversions do not
// need to do error checking.
impl TryFrom<(HttpReadState, Time)> for RawHttpRequest {
    type Error = HttpHandlerError;

    fn try_from(input: (HttpReadState, Time)) -> Result<Self, Self::Error> {
        use RawHttpRequestVal::*;
        let (read_state, current_time) = input;
        validate_ingress_expiry(read_state.ingress_expiry, current_time)?;

        let mut map = btreemap! {
            "request_type".to_string() => String("read_state".to_string()),
            "ingress_expiry".to_string() => U64(read_state.ingress_expiry),
            "paths".to_string() => Array(read_state
                    .paths
                    .iter()
                    .map(|p| {
                        RawHttpRequestVal::Array(
                            p.iter()
                                .map(|b| RawHttpRequestVal::Bytes(b.clone().to_vec()))
                                .collect(),
                        )
                    })
                    .collect()),
            "sender".to_string() => Bytes(read_state.sender.0),
        };
        if let Some(nonce) = read_state.nonce {
            map.insert("nonce".to_string(), Bytes(nonce.0));
        }
        Ok(Self(map))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
#[serde(tag = "status")]
pub enum HttpResponseStatus {
    Unknown,
    Received,
    Processing,
    Replied {
        reply: HttpReply,
    },
    Rejected {
        reject_code: u64,
        reject_message: String,
    },
}

/// The response to `/api/v1/read` with `request_type` set to `request_status`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub struct HttpRequestStatusResponse {
    #[serde(flatten)]
    pub status: HttpResponseStatus,
    pub time: Time,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(untagged)]
pub enum HttpReply {
    CodeCall { arg: Blob },
    Empty {},
}

/// The response to `/api/v1/read` with `request_type` set to `query`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
#[serde(tag = "status")]
pub enum HttpQueryResponse {
    Replied {
        reply: HttpQueryResponseReply,
    },
    Rejected {
        reject_code: u64,
        reject_message: String,
    },
}

/// The body of the `QueryResponse`
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HttpQueryResponseReply {
    pub arg: Blob,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HttpReadStateResponse {
    /// The CBOR-encoded `Certificate`.
    pub certificate: Blob,
}

/// A `Certificate` as defined in https://docs.dfinity.systems/public/#_certificate
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Certificate {
    pub tree: MixedHashTree,
    pub signature: Blob,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delegation: Option<CertificateDelegation>,
}

/// This enum is defined as a filler to make the encoding of `Certificate`
/// compliant with the public spec. It is not currently being used.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct CertificateDelegation {
    pub subnet_id: Blob,
    pub certificate: Blob,
}

/// The response to `/api/v1/status`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub struct HttpStatusResponse {
    pub ic_api_version: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub root_key: Option<Blob>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub impl_version: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub impl_hash: Option<String>,
}

#[cfg(test)]
mod test {
    use super::*;

    use crate::time::UNIX_EPOCH;
    use pretty_assertions::assert_eq;
    use serde::Serialize;
    use serde_cbor::Value;

    /// Makes sure that the serialized CBOR version of `obj` is the same as
    /// `Value`. Used when testing _outgoing_ messages from the HTTP
    /// Handler's point of view
    fn assert_cbor_ser_equal<T>(obj: &T, val: Value)
    where
        for<'de> T: Serialize,
    {
        assert_eq!(serde_cbor::value::to_value(obj).unwrap(), val)
    }

    fn text(text: &'static str) -> Value {
        Value::Text(text.to_string())
    }

    fn int(i: u64) -> Value {
        Value::Integer(i.into())
    }

    fn bytes(bs: &[u8]) -> Value {
        Value::Bytes(bs.to_vec())
    }

    #[test]
    fn encoding_read_query_response() {
        assert_cbor_ser_equal(
            &HttpQueryResponse::Replied {
                reply: HttpQueryResponseReply {
                    arg: Blob(b"some_bytes".to_vec()),
                },
            },
            Value::Map(btreemap! {
                text("status") => text("replied"),
                text("reply") => Value::Map(btreemap!{
                    text("arg") => bytes(b"some_bytes")
                })
            }),
        );
    }

    #[test]
    fn encoding_read_query_reject() {
        assert_cbor_ser_equal(
            &HttpQueryResponse::Rejected {
                reject_code: 1,
                reject_message: "system error".to_string(),
            },
            Value::Map(btreemap! {
                text("status") => text("rejected"),
                text("reject_code") => int(1),
                text("reject_message") => text("system error"),
            }),
        );
    }

    #[test]
    fn encoding_read_request_status_response_received() {
        assert_cbor_ser_equal(
            &HttpResponseStatus::Received,
            Value::Map(btreemap! {
                text("status") => text("received"),
            }),
        );
    }

    #[test]
    fn encoding_read_request_status_response_processing() {
        assert_cbor_ser_equal(
            &HttpResponseStatus::Processing,
            Value::Map(btreemap! {
                text("status") => text("processing"),
            }),
        );
    }

    #[test]
    fn encoding_read_request_status_response_replied() {
        assert_cbor_ser_equal(
            &HttpResponseStatus::Replied {
                reply: HttpReply::CodeCall {
                    arg: Blob(vec![0, 0, 0, 0]),
                },
            },
            Value::Map(btreemap! {
                text("status") => text("replied"),
                text("reply") => Value::Map(btreemap! {
                    text("arg") => bytes(&[0,0,0,0])
                }),
            }),
        );
    }

    #[test]
    fn encoding_read_request_status_response_replied_empty() {
        assert_cbor_ser_equal(
            &HttpResponseStatus::Replied {
                reply: HttpReply::Empty {},
            },
            Value::Map(btreemap! {
                text("status") => text("replied"),
                text("reply") => Value::Map(btreemap! {}),
            }),
        );
    }

    #[test]
    fn encoding_read_request_status_response_rejected() {
        assert_cbor_ser_equal(
            &HttpResponseStatus::Rejected {
                reject_code: 42,
                reject_message: "foo bar".to_string(),
            },
            Value::Map(btreemap! {
                text("status") => text("rejected"),
                text("reject_code") => int(42),
                text("reject_message") => text("foo bar"),
            }),
        );
    }

    /// Check RequestStateResponse can roundtrip through CBOR.
    #[test]
    fn request_state_response_roundtrips() {
        // An earlier version of the struct contained an i128, which doesn't roundtrip
        // through serde_cbor.
        let response = HttpRequestStatusResponse {
            status: HttpResponseStatus::Rejected {
                reject_code: 1,
                reject_message: "Something went wrong".to_string(),
            },
            time: crate::time::UNIX_EPOCH,
        };

        let encoded = serde_cbor::to_vec(&response).unwrap();
        let decoded: HttpRequestStatusResponse = serde_cbor::from_slice(&encoded[..]).unwrap();

        assert_eq!(response, decoded);
    }

    #[test]
    fn encoding_status_without_root_key() {
        assert_cbor_ser_equal(
            &HttpStatusResponse {
                ic_api_version: "foobar".to_string(),
                root_key: None,
                impl_version: Some("0.0".to_string()),
                impl_hash: None,
            },
            Value::Map(btreemap! {
                text("ic_api_version") => text("foobar"),
                text("impl_version") => text("0.0")
            }),
        );
    }

    #[test]
    fn encoding_status_with_root_key() {
        assert_cbor_ser_equal(
            &HttpStatusResponse {
                ic_api_version: "foobar".to_string(),
                root_key: Some(Blob(vec![1, 2, 3])),
                impl_version: Some("0.0".to_string()),
                impl_hash: None,
            },
            Value::Map(btreemap! {
                text("ic_api_version") => text("foobar"),
                text("root_key") => bytes(&[1, 2, 3]),
                text("impl_version") => text("0.0")
            }),
        );
    }

    #[test]
    fn encoding_delegation() {
        assert_cbor_ser_equal(
            &Delegation {
                pubkey: Blob(vec![1, 2, 3]),
                expiration: UNIX_EPOCH,
                targets: None,
            },
            Value::Map(btreemap! {
                text("pubkey") => bytes(&[1, 2, 3]),
                text("expiration") => int(0),
                text("targets") => Value::Null,
            }),
        );

        assert_cbor_ser_equal(
            &Delegation {
                pubkey: Blob(vec![1, 2, 3]),
                expiration: UNIX_EPOCH,
                targets: Some(vec![Blob(vec![4, 5, 6])]),
            },
            Value::Map(btreemap! {
                text("pubkey") => bytes(&[1, 2, 3]),
                text("expiration") => int(0),
                text("targets") => Value::Array(vec![bytes(&[4, 5, 6])]),
            }),
        );
    }

    #[test]
    fn encoding_signed_delegation() {
        assert_cbor_ser_equal(
            &SignedDelegation {
                delegation: Delegation {
                    pubkey: Blob(vec![1, 2, 3]),
                    expiration: UNIX_EPOCH,
                    targets: None,
                },
                signature: Blob(vec![4, 5, 6]),
            },
            Value::Map(btreemap! {
                text("delegation") => Value::Map(btreemap! {
                    text("pubkey") => bytes(&[1, 2, 3]),
                    text("expiration") => int(0),
                    text("targets") => Value::Null,
                }),
                text("signature") => bytes(&[4, 5, 6]),
            }),
        );
    }
}
