// DFN-467: clippy complains about the code generated by derive(Arbitrary)
#![cfg_attr(test, allow(clippy::unit_arg))]
//! This module defines the various http requests that the internet computer is
//! prepared to handle.

use super::{Blob, HttpHandlerError};
use crate::messages::{MessageId, UserSignature};
use crate::{
    crypto::SignedBytesWithoutDomainSeparator, ingress::MAX_INGRESS_TTL,
    messages::message_id::hash_of_map, messages::ReadState, messages::UserQuery, CountBytes, Time,
    UserId,
};
use ic_base_types::{CanisterId, PrincipalId};
use ic_crypto_tree_hash::{MixedHashTree, Path};
use ic_protobuf::types::v1 as pb;
use maplit::btreemap;
#[cfg(test)]
use proptest_derive::Arbitrary;
use serde::{Deserialize, Serialize};
use std::{
    collections::{BTreeMap, BTreeSet},
    convert::TryFrom,
};

/// Check if ingress_expiry has not expired with respect to the given time,
/// i.e., it is greater than or equal to current_time.
pub fn validate_ingress_expiry(
    ingress_expiry: u64,
    current_time: Time,
) -> Result<(), HttpHandlerError> {
    let min_allowed_expiry = current_time.as_nanos_since_unix_epoch();
    if ingress_expiry < min_allowed_expiry {
        let msg = format!(
            "Specified ingress_expiry {}ns is less than allowed expiry time {}ns",
            ingress_expiry, min_allowed_expiry,
        );
        return Err(HttpHandlerError::InvalidIngressExpiry(msg));
    }
    Ok(())
}

/// Check if ingress_expiry is within a proper range with respect to the given
/// time, i.e., it is not expired yet and is not too far in the future.
fn validate_ingress_expiry_range(
    ingress_expiry: u64,
    current_time: Time,
) -> Result<(), HttpHandlerError> {
    let provided_expiry = Time::from_nanos_since_unix_epoch(ingress_expiry);
    let min_allowed_expiry = current_time;
    let max_allowed_expiry = min_allowed_expiry + MAX_INGRESS_TTL;
    if !(min_allowed_expiry <= provided_expiry && provided_expiry <= max_allowed_expiry) {
        let msg = format!(
            "Specified ingress_expiry not within expected range:\n\
             Minimum allowed expiry: {}\n\
             Maximum allowed expiry: {}\n\
             Provided expiry:        {}\n\
             Local time:             {}",
            min_allowed_expiry,
            max_allowed_expiry,
            provided_expiry,
            chrono::Utc::now(),
        );
        return Err(HttpHandlerError::InvalidIngressExpiry(msg));
    }
    Ok(())
}

/// Describes the fields of a canister update call as defined in
/// https://docs.dfinity.systems/public#api-update.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct HttpCanisterUpdate {
    pub canister_id: Blob,
    pub method_name: String,
    pub arg: Blob,
    pub sender: Blob,
    /// Indicates when the message should expire.  Represented as nanoseconds
    /// since UNIX epoch.
    pub ingress_expiry: u64,
    // Do not include omitted fields in MessageId calculation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<Blob>,
}

impl HttpCanisterUpdate {
    /// Returns the representation-independent hash.
    pub fn representation_independent_hash(&self) -> [u8; 32] {
        hash_of_map(&self.representation_independent_map())
    }

    fn representation_independent_map(&self) -> BTreeMap<String, RawHttpRequestVal> {
        use RawHttpRequestVal::*;
        let mut map = btreemap! {
            "request_type".to_string() => String("call".to_string()),
            "canister_id".to_string() => Bytes(self.canister_id.0.clone()),
            "method_name".to_string() => String(self.method_name.clone()),
            "arg".to_string() => Bytes(self.arg.0.clone()),
            "ingress_expiry".to_string() => U64(self.ingress_expiry),
            "sender".to_string() => Bytes(self.sender.0.clone()),
        };
        if let Some(nonce) = &self.nonce {
            map.insert("nonce".to_string(), Bytes(nonce.0.clone()));
        }
        map
    }
}

impl CountBytes for HttpCanisterUpdate {
    fn count_bytes(&self) -> usize {
        let mut count = std::mem::size_of::<Self>()
            + self.canister_id.0.len()
            + self.method_name.len()
            + self.arg.0.len()
            + self.sender.0.len();
        if let Some(nonce) = &self.nonce {
            count += nonce.0.len();
        }
        count
    }
}

/// Describes the contents of a /api/v1/submit request.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
#[cfg_attr(test, derive(Arbitrary))]
#[serde(rename_all = "snake_case")]
#[serde(tag = "request_type")]
pub enum HttpSubmitContent {
    Call {
        #[serde(flatten)]
        update: HttpCanisterUpdate,
    },
}

impl HttpSubmitContent {
    /// Returns the representation-independent hash.
    pub fn representation_independent_hash(&self) -> [u8; 32] {
        match self {
            Self::Call { update } => update.representation_independent_hash(),
        }
    }
}

/// Describes the fields of a canister query call (a query from a user to a
/// canister) as defined in https://docs.dfinity.systems/public#api-query
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HttpUserQuery {
    pub canister_id: Blob,
    pub method_name: String,
    pub arg: Blob,
    pub sender: Blob,
    /// Indicates when the message should expire.  Represented as nanoseconds
    /// since UNIX epoch.
    pub ingress_expiry: u64,
    // Do not include omitted fields in MessageId calculation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<Blob>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HttpReadState {
    pub sender: Blob,
    // A list of paths, where a path is itself a sequence of labels.
    pub paths: Vec<Path>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub nonce: Option<Blob>,
    pub ingress_expiry: u64,
}

/// Describes the contents of a /api/v1/read request.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
#[serde(tag = "request_type")]
pub enum HttpReadContent {
    Query {
        #[serde(flatten)]
        query: HttpUserQuery,
    },
    ReadState {
        #[serde(flatten)]
        read_state: HttpReadState,
    },
}

impl HttpReadContent {
    /// Returns the representation-independent hash.
    pub fn representation_independent_hash(&self) -> [u8; 32] {
        match self {
            Self::Query { query } => query.representation_independent_hash(),
            Self::ReadState { read_state } => read_state.representation_independent_hash(),
        }
    }
}

impl HttpUserQuery {
    /// Returns the representation-independent hash.
    pub fn representation_independent_hash(&self) -> [u8; 32] {
        hash_of_map(&self.representation_independent_map())
    }

    fn representation_independent_map(&self) -> BTreeMap<String, RawHttpRequestVal> {
        use RawHttpRequestVal::*;
        let mut map = btreemap! {
            "request_type".to_string() => String("query".to_string()),
            "canister_id".to_string() => Bytes(self.canister_id.0.clone()),
            "method_name".to_string() => String(self.method_name.clone()),
            "arg".to_string() => Bytes(self.arg.0.clone()),
            "ingress_expiry".to_string() => U64(self.ingress_expiry),
            "sender".to_string() => Bytes(self.sender.0.clone()),
        };
        if let Some(nonce) = &self.nonce {
            map.insert("nonce".to_string(), Bytes(nonce.0.clone()));
        }
        map
    }
}

impl HttpReadState {
    /// Returns the representation-independent hash.
    pub fn representation_independent_hash(&self) -> [u8; 32] {
        hash_of_map(&self.representation_independent_map())
    }

    fn representation_independent_map(&self) -> BTreeMap<String, RawHttpRequestVal> {
        use RawHttpRequestVal::*;
        let mut map = btreemap! {
            "request_type".to_string() => String("read_state".to_string()),
            "ingress_expiry".to_string() => U64(self.ingress_expiry),
            "paths".to_string() => Array(self
                    .paths
                    .iter()
                    .map(|p| {
                        RawHttpRequestVal::Array(
                            p.iter()
                                .map(|b| RawHttpRequestVal::Bytes(b.clone().to_vec()))
                                .collect(),
                        )
                    })
                    .collect()),
            "sender".to_string() => Bytes(self.sender.0.clone()),
        };
        if let Some(nonce) = &self.nonce {
            map.insert("nonce".to_string(), Bytes(nonce.0.clone()));
        }
        map
    }
}

/// Describes the request envelope as defined in
/// https://docs.dfinity.systems/public#authentication.  The content should
/// either be `HttpSubmitContent` or `HttpReadContent`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct HttpRequestEnvelope<C> {
    pub content: C,
    pub sender_pubkey: Option<Blob>,
    pub sender_sig: Option<Blob>,
    pub sender_delegation: Option<Vec<SignedDelegation>>,
}

/// A strongly-typed version of HttpRequestEnvelope.
#[derive(Debug, PartialEq, Clone)]
pub struct HttpRequest<C> {
    id: MessageId,
    content: C,
    auth: Authentication,
}

/// The authentication associated with an HTTP request.
#[derive(Debug, PartialEq, Clone)]
pub enum Authentication {
    Authenticated(UserSignature),
    Anonymous,
}

/// Common attributes that all HTTP request contents should have.
pub trait HttpRequestContent {
    fn sender(&self) -> UserId;

    fn ingress_expiry(&self) -> u64;

    fn nonce(&self) -> Option<Vec<u8>>;
}

impl<C: HttpRequestContent> HttpRequest<C> {
    pub fn sender(&self) -> UserId {
        self.content.sender()
    }

    pub fn ingress_expiry(&self) -> u64 {
        self.content.ingress_expiry()
    }

    pub fn nonce(&self) -> Option<Vec<u8>> {
        self.content.nonce()
    }
}

impl<C> HttpRequest<C> {
    pub fn content(&self) -> &C {
        &self.content
    }

    pub fn id(&self) -> MessageId {
        self.id.clone()
    }

    pub fn authentication(&self) -> &Authentication {
        &self.auth
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum ReadContent {
    Query(UserQuery),
    ReadState(ReadState),
}

impl HttpRequestContent for ReadContent {
    fn sender(&self) -> UserId {
        match self {
            Self::ReadState(read_state) => read_state.source,
            Self::Query(query) => query.source,
        }
    }

    fn ingress_expiry(&self) -> u64 {
        match self {
            Self::ReadState(read_state) => read_state.ingress_expiry,
            Self::Query(query) => query.ingress_expiry,
        }
    }

    fn nonce(&self) -> Option<Vec<u8>> {
        match self {
            Self::ReadState(read_state) => read_state.nonce.clone(),
            Self::Query(query) => query.nonce.clone(),
        }
    }
}

impl TryFrom<HttpRequestEnvelope<HttpReadContent>> for HttpRequest<ReadContent> {
    type Error = HttpHandlerError;

    fn try_from(envelope: HttpRequestEnvelope<HttpReadContent>) -> Result<Self, Self::Error> {
        let auth = match (
            envelope.sender_pubkey,
            envelope.sender_sig,
            envelope.sender_delegation,
        ) {
            (Some(pubkey), Some(signature), delegation) => {
                Ok(Authentication::Authenticated(UserSignature {
                    signature: signature.0,
                    signer_pubkey: pubkey.0,
                    sender_delegation: delegation,
                }))
            }
            (None, None, None) => Ok(Authentication::Anonymous),
            rest => Err(Self::Error::MissingPubkeyOrSignature(format!(
                "Got {:?}",
                rest
            ))),
        }?;

        match envelope.content {
            HttpReadContent::Query { query } => {
                let id = MessageId::from(query.representation_independent_hash());
                Ok(HttpRequest {
                    content: ReadContent::Query(UserQuery::try_from(query)?),
                    auth,
                    id,
                })
            }

            HttpReadContent::ReadState { read_state } => {
                let id = MessageId::from(read_state.representation_independent_hash());
                Ok(HttpRequest {
                    content: ReadContent::ReadState(ReadState::try_from(read_state)?),
                    auth,
                    id,
                })
            }
        }
    }
}

/// Describes a delegation map as defined in
/// https://docs.dfinity.systems/public#delegation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct Delegation {
    pubkey: Blob,
    expiration: Time,
    targets: Option<Vec<Blob>>,
}

impl Delegation {
    pub fn new(pubkey: Vec<u8>, expiration: Time) -> Self {
        Self {
            pubkey: Blob(pubkey),
            expiration,
            targets: None,
        }
    }

    pub fn new_with_targets(pubkey: Vec<u8>, expiration: Time, targets: Vec<CanisterId>) -> Self {
        Self {
            pubkey: Blob(pubkey),
            expiration,
            targets: Some(targets.iter().map(|c| Blob(c.get().to_vec())).collect()),
        }
    }

    pub fn pubkey(&self) -> &Vec<u8> {
        &self.pubkey.0
    }

    pub fn expiration(&self) -> Time {
        self.expiration
    }

    pub fn targets(&self) -> Result<Option<BTreeSet<CanisterId>>, String> {
        match &self.targets {
            None => Ok(None),
            Some(targets) => {
                let mut target_canister_ids = BTreeSet::new();
                for target in targets {
                    target_canister_ids.insert(
                        CanisterId::new(
                            PrincipalId::try_from(target.0.as_slice())
                                .map_err(|e| format!("Error parsing canister ID: {}", e))?,
                        )
                        .map_err(|e| format!("Error parsing canister ID: {}", e))?,
                    );
                }
                Ok(Some(target_canister_ids))
            }
        }
    }
}

impl SignedBytesWithoutDomainSeparator for Delegation {
    fn as_signed_bytes_without_domain_separator(&self) -> Vec<u8> {
        use RawHttpRequestVal::*;

        let mut map = btreemap! {
            "pubkey" => Bytes(self.pubkey.0.clone()),
            "expiration" => U64(self.expiration.as_nanos_since_unix_epoch()),
        };
        if let Some(targets) = &self.targets {
            map.insert(
                "targets",
                Array(targets.iter().map(|t| Bytes(t.0.clone())).collect()),
            );
        }

        hash_of_map(&map).to_vec()
    }
}

/// Describes a delegation as defined in
/// https://docs.dfinity.systems/public#delegation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[cfg_attr(test, derive(Arbitrary))]
pub struct SignedDelegation {
    delegation: Delegation,
    signature: Blob,
}

impl SignedDelegation {
    pub fn new(delegation: Delegation, signature: Vec<u8>) -> Self {
        Self {
            delegation,
            signature: Blob(signature),
        }
    }

    pub fn delegation(&self) -> &Delegation {
        &self.delegation
    }

    pub fn take_delegation(self) -> Delegation {
        self.delegation
    }

    pub fn signature(&self) -> &Blob {
        &self.signature
    }
}

/// The different types of values supported in `RawHttpRequest`.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum RawHttpRequestVal {
    Bytes(#[serde(with = "serde_bytes")] Vec<u8>),
    String(String),
    U64(u64),
    Array(Vec<RawHttpRequestVal>),
}

impl CountBytes for RawHttpRequestVal {
    fn count_bytes(&self) -> usize {
        match self {
            Self::Bytes(bytes) => bytes.len(),
            Self::String(string) => string.len(),
            Self::U64(_) => 8,
            Self::Array(elements) => elements.iter().map(|e| e.count_bytes()).sum(),
        }
    }
}

impl From<&RawHttpRequestVal> for pb::HttpRequestVal {
    fn from(val: &RawHttpRequestVal) -> Self {
        Self {
            val: Some(match val {
                RawHttpRequestVal::Bytes(bytes) => {
                    pb::http_request_val::Val::RawBytes(bytes.to_vec())
                }
                RawHttpRequestVal::String(string) => {
                    pb::http_request_val::Val::Str(string.to_string())
                }
                RawHttpRequestVal::U64(v) => pb::http_request_val::Val::U64(*v),
                RawHttpRequestVal::Array(arr) => {
                    pb::http_request_val::Val::Array(pb::HttpRequestArr {
                        values: arr.iter().map(Self::from).collect(),
                    })
                }
            }),
        }
    }
}

/// A map of all the relevant information needed to compute a `MessageId`.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct RawHttpRequest(pub BTreeMap<String, RawHttpRequestVal>);

impl RawHttpRequest {
    pub(crate) fn take_bytes(&mut self, key: &str) -> Vec<u8> {
        match self.0.remove(key).unwrap() {
            RawHttpRequestVal::Bytes(raw) => raw,
            val => unreachable!("Expected `{}` to be a blob, got {:?}", key, val),
        }
    }

    pub(crate) fn take_string(&mut self, key: &str) -> String {
        match self.0.remove(key).unwrap() {
            RawHttpRequestVal::String(raw) => raw,
            val => unreachable!("Expected `{}` to be a String, got {:?}", key, val),
        }
    }

    pub(crate) fn take_u64(&mut self, key: &str) -> u64 {
        match self.0.remove(key).unwrap() {
            RawHttpRequestVal::U64(raw) => raw,
            val => unreachable!("Expected `{}` to be an int, got {:?}", key, val),
        }
    }

    pub(crate) fn take_sender(&mut self) -> UserId {
        let sender_field = "sender".to_string();
        UserId::from(match self.0.remove(&sender_field).unwrap() {
            RawHttpRequestVal::Bytes(raw) => {
                PrincipalId::try_from(&raw[..]).expect("Failed to parse source")
            }
            val => unreachable!("Expected `{}` to be a blob, got {:?}", sender_field, val),
        })
    }
}

impl CountBytes for RawHttpRequest {
    fn count_bytes(&self) -> usize {
        self.0
            .iter()
            .map(|(key, val)| key.len() + val.count_bytes())
            .sum()
    }
}

// TODO(akhi): Perhaps introduce a method to check if valid PrincipalId without
// building one.
fn validate_principal_id(field: &str, bytes: &[u8]) -> Result<(), HttpHandlerError> {
    match PrincipalId::try_from(bytes) {
        Ok(_) => Ok(()),
        Err(err) => Err(HttpHandlerError::InvalidPrincipalId(format!(
            "Converting {} to PrincipalId failed with {}",
            field, err,
        ))),
    }
}

// This is the first time this http request is parsed.  Perform all the validity
// checks here so that any further conversions do not need to do error checking.
impl TryFrom<(HttpCanisterUpdate, Time)> for RawHttpRequest {
    type Error = HttpHandlerError;

    fn try_from(input: (HttpCanisterUpdate, Time)) -> Result<Self, Self::Error> {
        let (update, current_time) = input;
        let canister_id_field = "canister_id".to_string();
        validate_principal_id(&canister_id_field, &update.canister_id.0)?;
        validate_ingress_expiry_range(update.ingress_expiry, current_time)?;

        Ok(Self(update.representation_independent_map()))
    }
}

// This is the first time this http request is parsed.  Perform all the validity
// checks here so that any further conversions do not need to do error checking.
impl TryFrom<(HttpUserQuery, Time)> for RawHttpRequest {
    type Error = HttpHandlerError;

    fn try_from(input: (HttpUserQuery, Time)) -> Result<Self, Self::Error> {
        let (query, current_time) = input;
        let canister_id_field = "canister_id".to_string();
        validate_principal_id(&canister_id_field, &query.canister_id.0)?;
        validate_ingress_expiry(query.ingress_expiry, current_time)?;

        Ok(Self(query.representation_independent_map()))
    }
}

// This is the first time this http request is parsed.  Perform all the validity
// checks (but not expiry check) here so that any further conversions do not
// need to do error checking.
impl TryFrom<(HttpReadState, Time)> for RawHttpRequest {
    type Error = HttpHandlerError;

    fn try_from(input: (HttpReadState, Time)) -> Result<Self, Self::Error> {
        let (read_state, current_time) = input;
        validate_ingress_expiry(read_state.ingress_expiry, current_time)?;
        Ok(Self(read_state.representation_independent_map()))
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
#[serde(tag = "status")]
pub enum HttpResponseStatus {
    Unknown,
    Received,
    Processing,
    Replied {
        reply: HttpReply,
    },
    Rejected {
        reject_code: u64,
        reject_message: String,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(untagged)]
pub enum HttpReply {
    CodeCall { arg: Blob },
    Empty {},
}

/// The response to `/api/v1/read` with `request_type` set to `query`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
#[serde(tag = "status")]
pub enum HttpQueryResponse {
    Replied {
        reply: HttpQueryResponseReply,
    },
    Rejected {
        reject_code: u64,
        reject_message: String,
    },
}

/// The body of the `QueryResponse`
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HttpQueryResponseReply {
    pub arg: Blob,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HttpReadStateResponse {
    /// The CBOR-encoded `Certificate`.
    pub certificate: Blob,
}

/// A `Certificate` as defined in https://docs.dfinity.systems/public/#_certificate
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct Certificate {
    pub tree: MixedHashTree,
    pub signature: Blob,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delegation: Option<CertificateDelegation>,
}

/// This enum is defined as a filler to make the encoding of `Certificate`
/// compliant with the public spec. It is not currently being used.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct CertificateDelegation {
    pub subnet_id: Blob,
    pub certificate: Blob,
}

/// The response to `/api/v1/status`.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub struct HttpStatusResponse {
    pub ic_api_version: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub root_key: Option<Blob>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub impl_version: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub impl_hash: Option<String>,
}

#[cfg(test)]
mod test {
    use super::*;

    use crate::time::UNIX_EPOCH;
    use pretty_assertions::assert_eq;
    use serde::Serialize;
    use serde_cbor::Value;

    /// Makes sure that the serialized CBOR version of `obj` is the same as
    /// `Value`. Used when testing _outgoing_ messages from the HTTP
    /// Handler's point of view
    fn assert_cbor_ser_equal<T>(obj: &T, val: Value)
    where
        for<'de> T: Serialize,
    {
        assert_eq!(serde_cbor::value::to_value(obj).unwrap(), val)
    }

    fn text(text: &'static str) -> Value {
        Value::Text(text.to_string())
    }

    fn int(i: u64) -> Value {
        Value::Integer(i.into())
    }

    fn bytes(bs: &[u8]) -> Value {
        Value::Bytes(bs.to_vec())
    }

    #[test]
    fn encoding_read_query_response() {
        assert_cbor_ser_equal(
            &HttpQueryResponse::Replied {
                reply: HttpQueryResponseReply {
                    arg: Blob(b"some_bytes".to_vec()),
                },
            },
            Value::Map(btreemap! {
                text("status") => text("replied"),
                text("reply") => Value::Map(btreemap!{
                    text("arg") => bytes(b"some_bytes")
                })
            }),
        );
    }

    #[test]
    fn encoding_read_query_reject() {
        assert_cbor_ser_equal(
            &HttpQueryResponse::Rejected {
                reject_code: 1,
                reject_message: "system error".to_string(),
            },
            Value::Map(btreemap! {
                text("status") => text("rejected"),
                text("reject_code") => int(1),
                text("reject_message") => text("system error"),
            }),
        );
    }

    #[test]
    fn encoding_read_request_status_response_received() {
        assert_cbor_ser_equal(
            &HttpResponseStatus::Received,
            Value::Map(btreemap! {
                text("status") => text("received"),
            }),
        );
    }

    #[test]
    fn encoding_read_request_status_response_processing() {
        assert_cbor_ser_equal(
            &HttpResponseStatus::Processing,
            Value::Map(btreemap! {
                text("status") => text("processing"),
            }),
        );
    }

    #[test]
    fn encoding_read_request_status_response_replied() {
        assert_cbor_ser_equal(
            &HttpResponseStatus::Replied {
                reply: HttpReply::CodeCall {
                    arg: Blob(vec![0, 0, 0, 0]),
                },
            },
            Value::Map(btreemap! {
                text("status") => text("replied"),
                text("reply") => Value::Map(btreemap! {
                    text("arg") => bytes(&[0,0,0,0])
                }),
            }),
        );
    }

    #[test]
    fn encoding_read_request_status_response_replied_empty() {
        assert_cbor_ser_equal(
            &HttpResponseStatus::Replied {
                reply: HttpReply::Empty {},
            },
            Value::Map(btreemap! {
                text("status") => text("replied"),
                text("reply") => Value::Map(btreemap! {}),
            }),
        );
    }

    #[test]
    fn encoding_read_request_status_response_rejected() {
        assert_cbor_ser_equal(
            &HttpResponseStatus::Rejected {
                reject_code: 42,
                reject_message: "foo bar".to_string(),
            },
            Value::Map(btreemap! {
                text("status") => text("rejected"),
                text("reject_code") => int(42),
                text("reject_message") => text("foo bar"),
            }),
        );
    }

    #[test]
    fn encoding_status_without_root_key() {
        assert_cbor_ser_equal(
            &HttpStatusResponse {
                ic_api_version: "foobar".to_string(),
                root_key: None,
                impl_version: Some("0.0".to_string()),
                impl_hash: None,
            },
            Value::Map(btreemap! {
                text("ic_api_version") => text("foobar"),
                text("impl_version") => text("0.0")
            }),
        );
    }

    #[test]
    fn encoding_status_with_root_key() {
        assert_cbor_ser_equal(
            &HttpStatusResponse {
                ic_api_version: "foobar".to_string(),
                root_key: Some(Blob(vec![1, 2, 3])),
                impl_version: Some("0.0".to_string()),
                impl_hash: None,
            },
            Value::Map(btreemap! {
                text("ic_api_version") => text("foobar"),
                text("root_key") => bytes(&[1, 2, 3]),
                text("impl_version") => text("0.0")
            }),
        );
    }

    #[test]
    fn encoding_delegation() {
        assert_cbor_ser_equal(
            &Delegation {
                pubkey: Blob(vec![1, 2, 3]),
                expiration: UNIX_EPOCH,
                targets: None,
            },
            Value::Map(btreemap! {
                text("pubkey") => bytes(&[1, 2, 3]),
                text("expiration") => int(0),
                text("targets") => Value::Null,
            }),
        );

        assert_cbor_ser_equal(
            &Delegation {
                pubkey: Blob(vec![1, 2, 3]),
                expiration: UNIX_EPOCH,
                targets: Some(vec![Blob(vec![4, 5, 6])]),
            },
            Value::Map(btreemap! {
                text("pubkey") => bytes(&[1, 2, 3]),
                text("expiration") => int(0),
                text("targets") => Value::Array(vec![bytes(&[4, 5, 6])]),
            }),
        );
    }

    #[test]
    fn encoding_signed_delegation() {
        assert_cbor_ser_equal(
            &SignedDelegation {
                delegation: Delegation {
                    pubkey: Blob(vec![1, 2, 3]),
                    expiration: UNIX_EPOCH,
                    targets: None,
                },
                signature: Blob(vec![4, 5, 6]),
            },
            Value::Map(btreemap! {
                text("delegation") => Value::Map(btreemap! {
                    text("pubkey") => bytes(&[1, 2, 3]),
                    text("expiration") => int(0),
                    text("targets") => Value::Null,
                }),
                text("signature") => bytes(&[4, 5, 6]),
            }),
        );
    }
}
